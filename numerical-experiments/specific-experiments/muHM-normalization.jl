using LinearAlgebra
using OperatorMonotoneCorrelationTools

function fAM(x)
    return (2*x)/(x+1)
end
fAM0 = 2
fAMpinf = 0

function fGM(x)
    return sqrt(x)
end
fGM0 = 0
fGMpinf = 0

#Example
# ρA = [0.262061 -0.432668 ; -0.432668 0.737939]

#inputs 
#ρA = hsrandomstate(2,2,true)
println("The first test shows that using fAM, it still collapses to the correct value for qubit isotropic
states")
ρA = 1/2*[1 0 ; 0 1]
fAMworksfordepol = true
for q = 0:0.01:1
    Ak, Bk = _depolkraus(q)

    valAM = qmaxcorrcoeff(ρA, Ak, Bk, fAM, fAM0, fAMpinf)
    valGM = qmaxcorrcoeff(ρA,Ak,Bk,fGM,fGM0,fGMpinf)
    diff = abs((1 - q) - valAM)
    diff1 = abs(valGM - valAM)
    max(diff,diff1) > 1e-8 ? fAMworksfordepol = false : nothing
end
fAMworksfordepol

println("The second example shows this is not the case for other states.")
#ρA = [0.262061 -0.432668 ; -0.432668 0.737939]
ρA = [3/4 1/4 ; 1/4 1/4]
println("We are considering ρAB generated by the depolarizing channel of parameter q=0.01")
println("Acting on the purification of ρA=", ρA)
Ak, Bk = _depolkraus(0.01)
println("First we show the code works appropriately on μ_{GM}")
valGM = qmaxcorrcoeff(ρA,Ak,Bk,fGM,fGM0,fGMpinf)

#We have to copy the code because the qmaxcorrcoeff will throw an error as the eigenvalues become too large
ρAsq = sqrt(ρA)
ρB = krausaction(Ak, Bk, ρA)
dB = size(ρB)[1]

#Kraus of Jf maps
ΩJfρAneghalf = Jfpsigmachoi(ρA, -1 / 2, fAM, fAM0, fAMpinf)
C, D = choitokraus(ΩJfρAneghalf, dA, dA)
ΩJfρBneghalf = Jfpsigmachoi(ρB, -1 / 2, fAM, fAM0, fAMpinf)
E, F = choitokraus(ΩJfρBneghalf, dB, dB)

#Kraus of Λ_{ ̃ρ_f}* ∘ Λ_{ ̃ρ_f}
Mw = Matrix{Any}[]
Rw = Matrix{Any}[]
for x1 in eachindex(Ak)
    for x2 in eachindex(Ak)
        for y1 in eachindex(C)
            for y2 in eachindex(C)
                for z1 in eachindex(E)
                    for z2 in eachindex(E)
                        push!(Mw, conj.(C[y2]) * ρAsq * Ak[x2]' * E[z2]' * E[z1] * Ak[x1] * transpose(ρAsq) * transpose(C[y1]))
                        push!(Rw, F[z2]' * Bk[x2]' * ρAsq * conj.(D[y2]) * transpose(D[y1]) * transpose(ρAsq) * Bk[x1] * F[z1])
                    end
                end
            end
        end
    end
end

#Get basis of Herm(A) with respect to HS
onb = genGellMann(dA)
pushfirst!(onb, ρAsq)

#Get standard matrix T
T = zeros(Complex, dA^2, dA^2)

for j in 1:dA^2
    #Action of Λ_{ ̃ρ_f}* ∘ Λ_{ ̃ρ_f} on ONB
    ejout = krausaction(Mw, Rw, onb[j])
    for i in 1:dA^2
        T[i, j] = tr(onb[i]' * ejout)
    end
end

#Get the eigenvalues
λ = eigvals(T)